<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Flow</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .fallback {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            z-index: -2;
        }
    </style>
</head>

<body>
    <div class="fallback"></div>
    <canvas id="bg"></canvas>

    <script>
        class ParticleFlow {
            constructor() {
                this.currentTime = this.getCurrentTimeOfDay();
                this.setup();
                this.createParticles();
                this.addEventListeners();
                this.startTimeUpdate();
                this.animate();
            }

            getCurrentTimeOfDay() {
                const hour = new Date().getHours();
                if (hour >= 5 && hour < 12) return 'morning';
                if (hour >= 12 && hour < 17) return 'afternoon';
                if (hour >= 17 && hour < 21) return 'evening';
                return 'night';
            }

            setup() {
                this.scene = new THREE.Scene();

                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.z = 50;

                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('bg'),
                    antialias: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x0a0a0a, 1);

                this.clock = new THREE.Clock();
                this.mouse = new THREE.Vector2();
                this.targetRotation = new THREE.Vector2();

                // Time-based colors
                this.timeColors = {
                    morning: {
                        primary: 0x64b5f6,
                        secondary: 0x90caf9,
                        background: 0x0a0a0a
                    },
                    afternoon: {
                        primary: 0x81c784,
                        secondary: 0xa5d6a7,
                        background: 0x0a0a0a
                    },
                    evening: {
                        primary: 0xff9800,
                        secondary: 0xffb74d,
                        background: 0x0a0a0a
                    },
                    night: {
                        primary: 0x7986cb,
                        secondary: 0x9fa8da,
                        background: 0x0a0a0a
                    }
                };
            }

            createParticles() {
                const particleCount = 30000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                const velocities = new Float32Array(particleCount * 3);

                const color1 = new THREE.Color(this.timeColors[this.currentTime].primary);
                const color2 = new THREE.Color(this.timeColors[this.currentTime].secondary);

                for (let i = 0; i < particleCount; i++) {
                    // Position
                    positions[i * 3] = (Math.random() - 0.5) * 100;     // x
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 100; // y
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 100; // z

                    // Color
                    const mixFactor = Math.random();
                    colors[i * 3] = color1.r * (1 - mixFactor) + color2.r * mixFactor;     // r
                    colors[i * 3 + 1] = color1.g * (1 - mixFactor) + color2.g * mixFactor; // g
                    colors[i * 3 + 2] = color1.b * (1 - mixFactor) + color2.b * mixFactor; // b

                    // Size
                    sizes[i] = Math.random() * 0.5 + 0.1;

                    // Velocity
                    velocities[i * 3] = (Math.random() - 0.5) * 0.02;     // vx
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.02; // vy
                    velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02; // vz
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.ShaderMaterial({
                    vertexShader: `
                        attribute float size;
                        varying vec3 vColor;

                        void main() {
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;

                        void main() {
                            vec2 center = gl_PointCoord - vec2(0.5);
                            float dist = length(center);
                            float alpha = 1.0 - smoothstep(0.45, 0.5, dist);
                            gl_FragColor = vec4(vColor, alpha);
                        }
                    `,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    vertexColors: true
                });

                this.particles = new THREE.Points(geometry, material);
                this.particles.userData.velocities = velocities;
                this.scene.add(this.particles);
            }

            startTimeUpdate() {
                setInterval(() => {
                    const newTime = this.getCurrentTimeOfDay();
                    if (this.currentTime !== newTime) {
                        this.currentTime = newTime;
                        this.updateColors();
                    }
                }, 60000);
            }

            updateColors() {
                if (!this.particles) return;

                const colors = this.particles.geometry.attributes.color.array;
                const color1 = new THREE.Color(this.timeColors[this.currentTime].primary);
                const color2 = new THREE.Color(this.timeColors[this.currentTime].secondary);

                for (let i = 0; i < colors.length; i += 3) {
                    const mixFactor = Math.random();
                    colors[i] = color1.r * (1 - mixFactor) + color2.r * mixFactor;
                    colors[i + 1] = color1.g * (1 - mixFactor) + color2.g * mixFactor;
                    colors[i + 2] = color1.b * (1 - mixFactor) + color2.b * mixFactor;
                }

                this.particles.geometry.attributes.color.needsUpdate = true;
                this.renderer.setClearColor(this.timeColors[this.currentTime].background);
            }

            updateParticles() {
                const positions = this.particles.geometry.attributes.position.array;
                const velocities = this.particles.userData.velocities;
                const time = this.clock.getElapsedTime() * 0.1;

                for (let i = 0; i < positions.length; i += 3) {
                    // Update position
                    positions[i] += velocities[i];
                    positions[i + 1] += velocities[i + 1];
                    positions[i + 2] += velocities[i + 2];

                    // Add some wave motion
                    positions[i] += Math.sin(time + positions[i + 1] * 0.1) * 0.01;
                    positions[i + 1] += Math.cos(time + positions[i] * 0.1) * 0.01;

                    // Wrap particles around boundaries
                    if (Math.abs(positions[i]) > 50) positions[i] *= -0.99;
                    if (Math.abs(positions[i + 1]) > 50) positions[i + 1] *= -0.99;
                    if (Math.abs(positions[i + 2]) > 50) positions[i + 2] *= -0.99;
                }

                this.particles.geometry.attributes.position.needsUpdate = true;
            }

            addEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                window.addEventListener('mousemove', (event) => {
                    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                    this.targetRotation.x = this.mouse.y * 0.5;
                    this.targetRotation.y = this.mouse.x * 0.5;
                });
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));

                // Update particle positions
                this.updateParticles();

                // Smooth camera rotation
                this.camera.rotation.x += (this.targetRotation.x - this.camera.rotation.x) * 0.02;
                this.camera.rotation.y += (this.targetRotation.y - this.camera.rotation.y) * 0.02;

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize if WebGL is supported
        if ('WebGLRenderingContext' in window) {
            new ParticleFlow();
        }
    </script>
</body>

</html>