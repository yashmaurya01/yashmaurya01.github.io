<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Privacy Engineer Portfolio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .loading-fallback {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #0a0a0a, #1a1a1a);
            z-index: -2;
        }
    </style>
</head>

<body>
    <div class="loading-fallback"></div>
    <canvas id="background-canvas"></canvas>

    <script>
        class PrivacyBackground {
            constructor() {
                this.canvas = document.getElementById('background-canvas');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    alpha: true
                });

                this.clock = new THREE.Clock();
                this.mouse = new THREE.Vector2();
                this.raycaster = new THREE.Raycaster();
                this.particles = [];
                this.currentTheme = null;
                this.targetTheme = null;
                this.isTransitioning = false;

                this.init();
            }

            init() {
                // Setup renderer
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);

                // Setup camera
                this.camera.position.z = 5;

                // Initialize object pools
                this.initObjectPools();

                // Setup event listeners
                window.addEventListener('resize', this.onResize.bind(this));
                window.addEventListener('mousemove', this.onMouseMove.bind(this));
                window.addEventListener('scroll', this.onScroll.bind(this));

                // Start render loop
                this.animate();

                // Set initial theme
                this.updateTheme();
                setInterval(() => this.updateTheme(), 60000);
            }

            initObjectPools() {
                // Geometries
                this.geometries = {
                    node: new THREE.IcosahedronGeometry(0.1, 1),
                    shield: new THREE.OctahedronGeometry(0.2, 0),
                    particle: new THREE.SphereGeometry(0.02, 8, 8)
                };

                // Materials
                this.materials = {
                    node: new THREE.MeshPhongMaterial({ color: 0x4a90e2 }),
                    shield: new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    }),
                    particle: new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.6
                    })
                };

                // Object pools
                this.pools = {
                    nodes: [],
                    shields: [],
                    particles: []
                };
            }

            createSceneObjects(theme) {
                // Clear existing objects
                this.clearScene();

                switch (theme) {
                    case 'morning':
                        this.createMorningScene();
                        break;
                    case 'afternoon':
                        this.createAfternoonScene();
                        break;
                    case 'evening':
                        this.createEveningScene();
                        break;
                    case 'night':
                        this.createNightScene();
                        break;
                }
            }

            createMorningScene() {
                // Create low-poly cityscape
                const cityGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);
                const cityMaterial = new THREE.MeshPhongMaterial({
                    color: 0x4a90e2,
                    transparent: true,
                    opacity: 0.8
                });

                for (let i = 0; i < 20; i++) {
                    const building = new THREE.Mesh(cityGeometry, cityMaterial);
                    building.position.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 10
                    );
                    building.scale.y = Math.random() * 2 + 1;
                    this.scene.add(building);
                }

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                const directionalLight = new THREE.DirectionalLight(0xffd700, 0.6);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(ambientLight, directionalLight);

                // Add particles
                this.createParticleSystem(100, 0xffd700);
            }

            createAfternoonScene() {
                // Create network mesh
                const networkGeometry = new THREE.BufferGeometry();
                const networkMaterial = new THREE.LineBasicMaterial({
                    color: 0x4a90e2,
                    opacity: 0.6,
                    transparent: true
                });

                const points = [];
                for (let i = 0; i < 100; i++) {
                    points.push(
                        new THREE.Vector3(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10
                        )
                    );
                }

                networkGeometry.setFromPoints(points);
                const network = new THREE.LineSegments(networkGeometry, networkMaterial);
                this.scene.add(network);

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(ambientLight, directionalLight);

                // Add shields
                this.createShields(20);
            }

            createEveningScene() {
                // Create fortress elements
                const fortressGeometry = new THREE.CylinderGeometry(0.5, 1, 2, 6);
                const fortressMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff9800,
                    transparent: true,
                    opacity: 0.7
                });

                for (let i = 0; i < 8; i++) {
                    const fortress = new THREE.Mesh(fortressGeometry, fortressMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    fortress.position.set(
                        Math.cos(angle) * 5,
                        0,
                        Math.sin(angle) * 5
                    );
                    this.scene.add(fortress);
                }

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xff9800, 0.3);
                const directionalLight = new THREE.DirectionalLight(0xff9800, 0.5);
                directionalLight.position.set(-1, 0.5, -1);
                this.scene.add(ambientLight, directionalLight);

                // Add particles
                this.createParticleSystem(150, 0xff9800);
            }

            createNightScene() {
                // Create star field
                const starGeometry = new THREE.BufferGeometry();
                const starMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.02,
                    transparent: true,
                    opacity: 0.8
                });

                const starPositions = [];
                for (let i = 0; i < 1000; i++) {
                    starPositions.push(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20
                    );
                }

                starGeometry.setAttribute('position',
                    new THREE.Float32BufferAttribute(starPositions, 3)
                );
                const stars = new THREE.Points(starGeometry, starMaterial);
                this.scene.add(stars);

                // Add lights
                const ambientLight = new THREE.AmbientLight(0x7986cb, 0.1);
                const pointLight = new THREE.PointLight(0x7986cb, 0.5);
                pointLight.position.set(0, 3, 0);
                this.scene.add(ambientLight, pointLight);

                // Add encrypted data streams
                this.createDataStreams();
            }

            createParticleSystem(count, color) {
                const particleGeometry = new THREE.BufferGeometry();
                const particleMaterial = new THREE.PointsMaterial({
                    color: color,
                    size: 0.05,
                    transparent: true,
                    opacity: 0.6
                });

                const positions = new Float32Array(count * 3);
                const velocities = new Float32Array(count * 3);

                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    positions[i3] = (Math.random() - 0.5) * 10;
                    positions[i3 + 1] = (Math.random() - 0.5) * 10;
                    positions[i3 + 2] = (Math.random() - 0.5) * 10;

                    velocities[i3] = (Math.random() - 0.5) * 0.02;
                    velocities[i3 + 1] = Math.random() * 0.02;
                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.02;
                }

                particleGeometry.setAttribute('position',
                    new THREE.BufferAttribute(positions, 3)
                );

                const particles = new THREE.Points(particleGeometry, particleMaterial);
                particles.userData.velocities = velocities;
                this.scene.add(particles);
                this.particles.push(particles);
            }

            createDataStreams() {
                const streamGeometry = new THREE.BufferGeometry();
                const streamMaterial = new THREE.LineBasicMaterial({
                    color: 0x7986cb,
                    transparent: true,
                    opacity: 0.3
                });

                const points = [];
                for (let i = 0; i < 20; i++) {
                    const curve = new THREE.CubicBezierCurve3(
                        new THREE.Vector3(-5, Math.random() * 10 - 5, 0),
                        new THREE.Vector3(-2, Math.random() * 10 - 5, 2),
                        new THREE.Vector3(2, Math.random() * 10 - 5, -2),
                        new THREE.Vector3(5, Math.random() * 10 - 5, 0)
                    );

                    points.push(...curve.getPoints(50));
                }

                streamGeometry.setFromPoints(points);
                const streams = new THREE.LineSegments(streamGeometry, streamMaterial);
                this.scene.add(streams);
            }

            updateParticles() {
                this.particles.forEach(particle => {
                    const positions = particle.geometry.attributes.position.array;
                    const velocities = particle.userData.velocities;

                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += velocities[i];
                        positions[i + 1] += velocities[i + 1];
                        positions[i + 2] += velocities[i + 2];

                        // Reset particles that go out of bounds
                        if (Math.abs(positions[i + 1]) > 5) {
                            positions[i + 1] = -5;
                        }
                    }

                    particle.geometry.attributes.position.needsUpdate = true;
                });
            }

            clearScene() {
                while (this.scene.children.length > 0) {
                    const object = this.scene.children[0];
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                    this.scene.remove(object);
                }
                this.particles = [];
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // Update camera position slightly based on mouse movement
                gsap.to(this.camera.position, {
                    x: this.mouse.x * 0.5,
                    y: this.mouse.y * 0.5,
                    duration: 1
                });
            }

            onScroll() {
                const scrollPercent = window.scrollY / (document.documentElement.scrollHeight - window.innerHeight);
                this.camera.position.z = 5 + scrollPercent * 2;
            }

            updateTheme() {
                const hour = new Date().getHours();
                let newTheme;

                // if (hour >= 5 && hour < 12) newTheme = 'morning';
                // else if (hour >= 12 && hour < 17) newTheme = 'afternoon';
                // else if (hour >= 17 && hour < 21) newTheme = 'evening';
                // else newTheme = 'night';
                newTheme = 'evening';

                if (this.currentTheme !== newTheme) {
                    this.transitionToTheme(newTheme);
                }
            }

            transitionToTheme(newTheme) {
                if (this.isTransitioning) return;
                this.isTransitioning = true;

                // Fade out current scene
                gsap.to(this.scene.children, {
                    duration: 1,
                    opacity: 0,
                    onComplete: () => {
                        this.createSceneObjects(newTheme);
                        this.currentTheme = newTheme;

                        // Fade in new scene
                        gsap.to(this.scene.children, {
                            duration: 1,
                            opacity: 1,
                            onComplete: () => {
                                this.isTransitioning = false;
                            }
                        });
                    }
                });
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));

                const delta = this.clock.getDelta();

                // Update particles
                this.updateParticles();

                // Rotate camera slightly based on mouse position
                if (!this.isTransitioning) {
                    this.camera.rotation.x += (this.mouse.y * 0.01 - this.camera.rotation.x) * 0.05;
                    this.camera.rotation.y += (this.mouse.x * 0.01 - this.camera.rotation.y) * 0.05;
                }

                // Update all animated objects
                this.scene.children.forEach(child => {
                    if (child.userData.animate) {
                        child.userData.animate(delta);
                    }
                });

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Check for WebGL support
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext &&
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }

        // Initialize background if WebGL is supported
        if (checkWebGLSupport()) {
            const background = new PrivacyBackground();
        } else {
            console.warn('WebGL not supported, falling back to static background');
            document.body.classList.add('no-webgl');
        }
    </script>

    <!-- Fallback styles for non-WebGL devices -->
    <style>
        .no-webgl .loading-fallback {
            background: linear-gradient(45deg,
                    var(--bg-color-1, #0a0a0a) 0%,
                    var(--bg-color-2, #1a1a1a) 100%);
        }

        @media (prefers-reduced-motion: reduce) {
            .loading-fallback {
                display: block !important;
            }

            #background-canvas {
                display: none;
            }
        }
    </style>
</body>

</html>