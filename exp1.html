<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Portfolio Background</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .fallback {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #1a1a1a, #2a2a2a);
            z-index: -2;
        }
    </style>
</head>

<body>
    <div class="fallback"></div>
    <canvas id="bg"></canvas>

    <script>
        class PortfolioBackground {
            constructor() {
                this.setup();
                this.createMaterials();
                this.createScene();
                this.createLights();
                this.addEventListeners();
                this.animate();

                this.updateTimeOfDay();
                setInterval(() => this.updateTimeOfDay(), 60000);
            }

            setup() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 2, 5);

                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('bg'),
                    antialias: true,
                    alpha: true
                });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);

                this.mouse = new THREE.Vector2();
                this.targetRotation = new THREE.Vector2();
                this.currentTime = 'morning';
            }

            createMaterials() {
                this.materials = {
                    morning: new THREE.MeshPhysicalMaterial({
                        color: 0xe0e0e0,
                        metalness: 0.2,
                        roughness: 0.8,
                        flatShading: true
                    }),
                    afternoon: new THREE.MeshPhysicalMaterial({
                        color: 0xf5f5f5,
                        metalness: 0.3,
                        roughness: 0.7,
                        flatShading: true
                    }),
                    evening: new THREE.MeshPhysicalMaterial({
                        color: 0xffd7c4,
                        metalness: 0.4,
                        roughness: 0.6,
                        flatShading: true
                    }),
                    night: new THREE.MeshPhysicalMaterial({
                        color: 0x2c3e50,
                        metalness: 0.5,
                        roughness: 0.5,
                        flatShading: true
                    })
                };
            }

            createScene() {
                // Create low-poly terrain
                const geometry = new THREE.PlaneGeometry(15, 15, 32, 32);

                // Add height variation
                const vertices = geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    vertices[i + 2] = Math.random() * 0.5;
                }
                geometry.computeVertexNormals();

                this.terrain = new THREE.Mesh(geometry, this.materials.morning);
                this.terrain.rotation.x = -Math.PI / 2;
                this.terrain.position.y = -2;
                this.scene.add(this.terrain);

                // Add geometric shapes
                const shapes = [];
                const shapeCount = 20;
                const geometries = [
                    new THREE.TetrahedronGeometry(0.3),
                    new THREE.OctahedronGeometry(0.3),
                    new THREE.IcosahedronGeometry(0.3)
                ];

                for (let i = 0; i < shapeCount; i++) {
                    const geometry = geometries[Math.floor(Math.random() * geometries.length)];
                    const shape = new THREE.Mesh(geometry, this.materials.morning);

                    shape.position.set(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 3 - 1,
                        (Math.random() - 0.5) * 10
                    );

                    shape.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );

                    shapes.push(shape);
                    this.scene.add(shape);
                }

                this.shapes = shapes;
            }

            createLights() {
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(this.ambientLight);

                this.mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                this.mainLight.position.set(2, 2, 2);
                this.scene.add(this.mainLight);

                // Add subtle rim light
                this.rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
                this.rimLight.position.set(-2, 2, -2);
                this.scene.add(this.rimLight);
            }

            updateTimeOfDay() {
                const hour = new Date().getHours();
                let newTime;

                if (hour >= 5 && hour < 12) newTime = 'morning';
                else if (hour >= 12 && hour < 17) newTime = 'afternoon';
                else if (hour >= 17 && hour < 21) newTime = 'evening';
                else newTime = 'night';

                if (this.currentTime !== newTime) {
                    this.transitionToTime(newTime);
                }
            }

            transitionToTime(newTime) {
                const newMaterial = this.materials[newTime];
                const lightSettings = {
                    morning: { intensity: 0.8, color: 0xffffff },
                    afternoon: { intensity: 1.0, color: 0xffffff },
                    evening: { intensity: 0.7, color: 0xffd7c4 },
                    night: { intensity: 0.4, color: 0x4a4a6a }
                };

                // Transition all mesh materials
                [this.terrain, ...this.shapes].forEach(mesh => {
                    gsap.to(mesh.material.color, {
                        r: newMaterial.color.r,
                        g: newMaterial.color.g,
                        b: newMaterial.color.b,
                        duration: 2
                    });
                });

                // Transition lighting
                gsap.to(this.mainLight, {
                    intensity: lightSettings[newTime].intensity,
                    duration: 2
                });

                gsap.to(this.mainLight.color, {
                    r: new THREE.Color(lightSettings[newTime].color).r,
                    g: new THREE.Color(lightSettings[newTime].color).g,
                    b: new THREE.Color(lightSettings[newTime].color).b,
                    duration: 2
                });

                this.currentTime = newTime;
            }

            addEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                window.addEventListener('mousemove', (event) => {
                    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                    // Subtle camera movement
                    this.targetRotation.x = this.mouse.y * 0.2;
                    this.targetRotation.y = this.mouse.x * 0.2;
                });
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));

                // Smooth camera movement
                this.camera.rotation.x += (this.targetRotation.x - this.camera.rotation.x) * 0.05;
                this.camera.rotation.y += (this.targetRotation.y - this.camera.rotation.y) * 0.05;

                // Subtle shape rotation
                this.shapes.forEach(shape => {
                    shape.rotation.x += 0.001;
                    shape.rotation.y += 0.001;
                });

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize if WebGL is supported
        if ('WebGLRenderingContext' in window) {
            new PortfolioBackground();
        }
    </script>
</body>

</html>